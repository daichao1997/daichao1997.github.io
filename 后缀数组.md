# 后缀数组

朕听说，后缀数组只需寥寥二十行代码即可求出？

是的，陛下。

快，快呈上来！

是，陛下。

```cpp
int wa[MAXN], wb[MAXN], wv[MAXN], ws[MAXN];
inline bool cmp(int *r, int a, int b, int len) {
	return r[a]==r[b] && r[a+len]==r[b+len];
}
void SA(char *r, int *sa, int n, int m)
{
	int i, j, p, *x = wa, *y = wb, *t;	
	for (i = 0; i < m; i++) ws[i] = 0;
	for (i = 0; i < n; i++) ws[x[i] = r[i]]++;
	for (i = 1; i < m; i++) ws[i] += ws[i - 1];
	for (i = n - 1; i >= 0; i--) sa[--ws[x[i]]] = i;
	for (j = p = 1; p < n; j <<= 1, m = p)
	{
		for (p = 0, i = n - j; i < n; i++) y[p++] = i;
		for (i = 0; i < n; i++) if (sa[i] >= j) y[p++] = sa[i] - j;
		for (i = 0; i < m; i++) ws[i] = 0;
		for (i = 0; i < n; i++) ws[wv[i] = x[y[i]]]++;
		for (i = 1; i < m; i++) ws[i] += ws[i - 1];
		for (i = n - 1; i >= 0; i--) sa[--ws[wv[i]]] = y[i];
		for (t=x,x=y,y=t, x[sa[0]]=0, p=i=1; i<n; i++)
			x[sa[i]] = cmp(y,sa[i-1],sa[i],j) ? p-1 : p++;
	}
}
```

陛下……陛下！快请御医！

## 前言

鉴于我也是第一次接触后缀数组，理解程度还很低，再加上类似的博客早已烂大街，因此不求读者能看懂或学到什么东西了。你还可以向我[留言](mailto:fordring866@gmail.com)提出指导意见，我会非常欢迎。

## 什么是后缀数组

今天，我们来谈谈这份“后缀数组”的模板。

这份模板，是用来求“后缀数组”的。

后缀很简单，数组也很简单，但是“后缀数组”就需要解释一番了。

一个长为N的字符串，有N个后缀，每个后缀都从不同的位置开始。

我们用`suffix(i)`表示从第i个字符开始的后缀（从0计）。例如，"abcdefg"的suffix(2)就是"cdefg"。

也就是说，只要确定了字符串，我们就可以用[0, N-1]的数字表示任意一个后缀。

然后，这些后缀作为字符串，是可以按照**字典序**来排列的。

把`suffix(0)...suffix(N-1)`从小到大排列后，会被打乱为`suffix(sa[0])...suffix(sa[i])`。

这里的`sa`是0到N-1的一个排列，同时也可以视为数组。

它就是**后缀数组(suffix array)**，`sa[i]`就是第i小的后缀在原字符串的位置（从0开始计数），而`suffix(sa[i])`就是第i小的后缀。

那么，我们为什么要求这个数组呢？

不知道，听大佬们说很有用，所以先求出来再说吧。

## 暴力求法

假如逐一比较两个后缀的字符，就需要比较O(N)次，才能知道两个后缀的相对大小。（因为它们的长度在1到N之间）

假如用插入排序，就需要比较O(N^2)次后缀。

乘起来就是O(N^3)，不能忍。

## 文明求法

目前已经有好几种O(N)的算法，确实厉害，但我懒得看。

## 倍增法

前面那段外星代码，使用的就是倍增法。

我先定义一个概念，叫做**k-后缀**。它也是字符串的后缀，但它长度至多为k——我把它后面的部分截断了。

比如，"abcdefg"的4-后缀分别是"abcd", "bcde", "cdef", "defg", "efg", "fg"和"g"。

为了方便表示，我就借用之前的符号，用`suffix(i,k)`表示**从第i个字符开始的k-后缀**吧。

相应地，`sa(k)`就叫做k-后缀数组，`suffix(sa(k)[i],k)`就是第i小的k-后缀。

倍增法的思路就是递推，先求`sa(1)`，再求`sa(2)`、`sa(4)`，直到k-后缀成为完整的后缀，sa也就出来了。

### 求sa(1)

`sa(1)`，1-后缀数组，`sa(1)[i]`就是第i小的1-后缀的位置。

第i小的1-后缀……那不就是第i小的字符么？听上去很简单的样子。

也就是说，我只要知道每个字符是串中第几小就好了。下面的代码完成了这件事情。

```cpp
for (i = 0; i < m; i++) ws[i] = 0;
for (i = 0; i < n; i++) ws[x[i] = r[i]]++;
for (i = 1; i < m; i++) ws[i] += ws[i - 1];
for (i = n - 1; i >= 0; i--) sa[--ws[x[i]]] = i;
```

变量介绍：
- i：打酱油的递增变量
- m：字符串最多有m种字符
- n：字符串长度
- r：字符串
- sa：1-后缀数组
- ws：统计每种字符出现了几次
- x：此处等同于r

第一句：`for (i = 0; i < m; i++) ws[i] = 0;`

清零ws数组。

第二句：`for (i = 0; i < n; i++) ws[x[i] = r[i]]++;`

- 执行`x[i] = r[i]`表达式，把r的值逐渐复制到x
- 上述表达式的值就是r[i]，即位置i的字符的值
- `ws[x[i] = r[i]]++`：值为r[i]的字符又多了一个

之后，ws就存储了r（或者x）中每种字符的个数。

第三句：`for (i = 1; i < m; i++) ws[i] += ws[i - 1];`

这句完成后，新的ws[i]成为了原来的`ws[0]+ws[1]+...+ws[i]`，意为x中有多少字符的值不大于i。

第四句：`for (i = n - 1; i >= 0; i--) sa[--ws[x[i]]] = i;`（倒序遍历）

结合1-后缀数组的定义，这句话的意思是，第`--ws[x[i]]`小的字符，应该在位置i。
- `x[i]`是位置i的字符，`ws[x[i]]`就是不大于该字符的字符个数
- 排名从0开始，如果不大于自己的有k个，那自己就应该是第k-1名，所以是`--a`而不是`a--`
- 如果有并列，则希望位置小的字符更小，因此进行倒序遍历，让大的位置先坐进sa，这样它在sa的位置也更大
- 既然坐进了sa数组，就该从ws中去掉自己，所以ws[x[i]]应该自减

短小精悍，不是吗？

### 求sa(2)

### 从sa(k)到sa(2k)

### 循环的终止